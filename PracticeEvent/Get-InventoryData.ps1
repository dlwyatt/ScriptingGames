<#
.Synopsis
   Collects inventory data from active computers in a subnet.
.DESCRIPTION
   Collects inventory data from one or more remote computers, based on CSV file(s) generated by Get-ComputersInSubnet.ps1.
.PARAMETER CsvPath
   Path to a CSV file produced by Get-ComputersInSubnet.ps1.  This path may contain wildcards (ie, "C:\IPScans\*.csv").
.PARAMETER OutputDirectory
   The directory where the output XML file should be saved.  The file names will match the names of the input CSV files, with "_Inventory" appended.  For example, "192.168.0.0_24-2014-01-10.csv" would produce an XML file named "192.168.0.0_24-2014-01-10_Inventory.xml"
.PARAMETER HardwareInfo
   When the HardwareInfo switch is specified, the inventory will contain the following data for each computer:

   Manufacturer and Model of the computer.
   Total physical RAM.
   CPU information (Name, Speed, Architecture, Core and Logical Processor count for each physical CPU)
   Disk information (Drive Letter, Volume Name, Size, Free Space and File System for each logical drive on a local disk.)
.PARAMETER LastHotfix
   When the LastHotfix switch is specified, the inventory will contain the date and time at which the most recent operating system patch was installed on each computer.
.PARAMETER LastReboot
   When the LastReboot switch is specified, the inventory will contain the date and time at which each computer was last booted.
.PARAMETER InstalledServerApps
   When the InstalledServerApps switch is specified, the inventory will contain boolean values indicating whether IIS, Exchange, SQL Server or SharePoint are installed on each computer.
.PARAMETER WindowsComponents
   When the WindowsComponents switch is specified, the inventory will contain a list of installed Windows optional components
.NOTES
   This script requires PowerShell version 4.0, and assumes that the user running the script has permissions to query WMI on all remote machines.

   The XML files are generated with the Export-CliXml cmdlet.  To read the files back in for later analysis, use the Import-CliXml cmdlet.
.EXAMPLE
   .\Get-InventoryData.ps1 -CsvPath 'C:\IPScans\192.168.0.0_24-2014-01-10.csv' -OutputDirectory 'C:\IPScans' -HardwareInfo

   Queries the active computers from the C:\IPScans\192.168.0.0_24-2014-01-10.csv file.  Collects basic hardware information about each computer, and saves the results to XML file C:\IPScans\192.168.0.0_24-2014-01-10_Inventory.xml
.EXAMPLE
   .\Get-InventoryData.ps1 -CsvPath 'C:\IPScans\*.csv' -OutputDirectory 'c:\IPScans\' -HardwareInfo -LastHotfix -LastReboot -InstalledServerApps -WindowsComponents

   Performs inventory collection based on all CSV files in the C:\IPScans directory.  Each CSV file will have a separate inventory XML file produced, and the inventories will contain the full set of information that this script supports.
.INPUTS
   String
.OUTPUTS
   None.  This script does not produce pipeline output.
#>

#requires -Version 4.0

[CmdletBinding()]
param (
    [Parameter(Mandatory, ValueFromPipeline)]
    [string[]]
    $CsvPath,

    [ValidateNotNullOrEmpty()]
    [string]
    $OutputDirectory = '.',

    [switch]
    $HardwareInfo,

    [switch]
    $LastHotfix,

    [switch]
    $LastReboot,

    [switch]
    $InstalledServerApps,

    [switch]
    $WindowsComponents
)

begin
{
    Import-Module -Name .\PracticeModule.psm1 -ErrorAction Stop -Verbose:$false

    if (-not (Test-Path -Path $OutputDirectory -PathType Container))
    {
        try
        {
            $null = New-Item -Path $OutputDirectory -ItemType Directory -ErrorAction Stop
        }
        catch
        {
            throw "Error creating directory '$OutputDirectory':`r`n$($_ | Out-String)"
        }
    }
}

process
{
    $null = $PSBoundParameters.Remove('OutputDirectory')
    $null = $PSBoundParameters.Remove('CsvPath')

    foreach ($path in $CsvPath)
    {
        $folder = Split-Path -Path $path -Parent
        $fileName = Split-Path -Path $path -Leaf

        if ([string]::IsNullOrEmpty($folder))
        {
            $folder = $PSCmdlet.SessionState.Path.CurrentFileSystemLocation
        }

        $matchingFiles = Get-ChildItem -File -Path $folder |
                         Where-Object Name -like $fileName

        foreach ($file in $matchingFiles)
        {
            $csvFile = $file.FullName

            Write-Verbose "Processing input file '$csvFile'."

            $activeComputers = Import-Csv -LiteralPath $csvFile |
                               Where-Object OperatingSystem -ne ''

            $count = $activeComputers.Count
            
            if ($count -eq 0)
            {
                Write-Verbose "No active computers detected in file '$csvFile'.  No XML output is being generated for this file."
                continue
            }
            
            $current = 1

            $inventoryData = foreach ($entry in $activeComputers)
            {
                $ip = $entry.IPAddress

                Write-Progress -Activity "Querying active computers from file '$csvFile'" -PercentComplete (100 * $current / $count) -Status "Computer $current of $count ($ip)"
                $current++

                $data = Get-InventoryData -ComputerName $ip @PSBoundParameters

                if ($null -eq $data)
                {
                    $data = New-Object psobject -Property ([ordered]@{
                        IPAddress = $ip
                        OperatingSystem = $entry.OperatingSystem
                        ServicePack = $entry.ServicePack
                    })
                }
                else
                {
                    Add-Member -InputObject $data -NotePropertyName IPAddress -NotePropertyValue $ip
                    Add-Member -InputObject $data -NotePropertyName OperatingSystem -NotePropertyValue $entry.OperatingSystem
                    Add-Member -InputObject $data -NotePropertyName ServicePack -NotePropertyValue $entry.ServicePack
                }

                Write-Output $data
            }

            Write-Progress -Activity "Querying active computers from file '$csvFile'" -Completed

            $baseFileName = [System.IO.Path]::GetFileNameWithoutExtension($csvFile) + "_Inventory"
            $suffix = 1

            $fileName = Join-Path -Path $OutputDirectory -ChildPath "$baseFileName.xml"

            while (Test-Path -Path $fileName)
            {
                $fileName = Join-Path -Path $OutputDirectory -ChildPath "${baseFileName}_$suffix.xml"
                $suffix++
            }

            Write-Verbose "Finished processing input file '$csvFile'.  Saving inventory data to file '$fileName'."

            $inventoryData | Export-Clixml -LiteralPath $fileName

        } # foreach ($file in $matchingFiles)

    } # foreach ($path in $CsvPath)

} # process
